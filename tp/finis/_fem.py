import ast
import numpy as np
from scipy.sparse import csr_matrix
from ._mesh import triangle_x, triangle_y, triangle_cog
from ._integrate import form_int_2d
from ._edges import meshEdges


def lagrange_1d(x_in, order=1):
    N = x_in.size

    x = x_in

    if len(x_in.shape) == 1:
        x = x_in[:, None]

    if order == 0:
        return np.ones((N, 1)), np.zeros((N, 1))

    if order == 1:
        phi = np.hstack((1.0 - x, x))
        dxphi = np.hstack((-np.ones((N, 1)), np.ones((N, 1))))

        assert(phi.flags['OWNDATA'])
        assert(dxphi.flags['OWNDATA'])

        return phi, dxphi

    raise NotImplementedError("Only orders 0 and 1 are implemented")


def lagrange_2d(x_in, y_in, order=1):
    N = x_in.size

    x = x_in
    y = y_in

    if len(x_in.shape) == 1:
        x = x_in[:, None]
    if len(y_in.shape) == 1:
        y = y_in[:, None]

    if order == 0:
        return np.ones((N, 1)), np.zeros((N, 1)), np.zeros((N, 1))

    if order == 1:
        phi = np.hstack((1.0 - x - y, x, y))
        dxphi = np.hstack(
            (-np.ones((N, 1)), np.ones((N, 1)), np.zeros((N, 1))))
        dyphi = np.hstack(
            (-np.ones((N, 1)), np.zeros((N, 1)), np.ones((N, 1))))

        assert(phi.flags['OWNDATA'])
        assert(dxphi.flags['OWNDATA'])
        assert(dyphi.flags['OWNDATA'])

        return phi, dxphi, dyphi

    if order == 2:
        s = b'\x00\x00\x00\x00\x00\x00\xf0?\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\xc0\x00\x00\x00\x00\x00\x00\xf0\xbf\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10@\x00\x00\x00\x00\x00\x00\x08\xc0\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\xf0\xbf\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x10\xc0\x00\x00\x00\x00\x00\x00\x10@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x10@\x00\x00\x00\x00\x00\x00\x10\xc0\x00\x00\x00\x00\x00\x00\x10\xc0\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x10\xc0\x00\x00\x00\x00\x00\x00\x00\x80'
        C = np.frombuffer(s).reshape((6, 6))

        V = np.hstack((np.ones_like(x), x, y, x**2, x * y, y**2))
        dxV = np.hstack(
            (np.zeros_like(x),
             np.ones_like(x),
             np.zeros_like(x),
             2 * x,
             y,
             np.zeros_like(x)))
        dyV = np.hstack(
            (np.zeros_like(x),
             np.zeros_like(x),
             np.ones_like(x),
             np.zeros_like(x),
             x,
             2 * y))

        phi = np.dot(V, C)
        dxphi = np.dot(dxV, C)
        dyphi = np.dot(dyV, C)

        assert(phi.flags['OWNDATA'])
        assert(dxphi.flags['OWNDATA'])
        assert(dyphi.flags['OWNDATA'])

        return phi, dxphi, dyphi

    raise NotImplementedError("Only orders 0, ..., 2 are implemented")


def _fe_dof(mesh, order=1):
    """
    Compute the finite element degrees of freedom for a given mesh.

    Parameters
    ----------
    mesh : triangle mesh
        Generated by calling finis.triangulate or triangle.triangulate (more general).
    order : int, optional
        Order of the shape functions. Currently {0, 1, 2} are implemented.

    Returns
    -------
    dof : (N_dof, 2) ndarray
            Coordinates of the degrees of freedom, e.g. the coordinates of the vertices for order=1.
            N_dof is the number of degrees of freedom.
    num_dof : (N_tri, N_b) ndarray
            N_tri is the number of triangles and N_b is the number of shape functions per triangle, e.g. 3 for order=1.
            num_dof[i,:] are the degrees of freedom for triangle i (by their index).

    See Also
    --------
    finis.fe_space
    """

    if (order < 0) or (order > 2):
        raise NotImplementedError(
            "Only shape functions of order 0, 1, 2 are implemented")

    N_tri = mesh['triangles'].shape[0]  # Number of triangles
    N_vert = mesh['vertices'].shape[0]  # number of vertices

    if order == 0:
        # Center of gravity
        dof = triangle_cog(mesh)
        num_dof = np.arange(N_tri)[:, None]

    if order == 1:
        # Vertices
        dof = np.copy(mesh['vertices'])
        num_dof = np.copy(mesh['triangles'])

    if order == 2:
        # Vertices and middle of edges
        edge, edge_markers, ElementEdges = meshEdges(mesh)

        xy_edge1 = mesh['vertices'][edge[:, 0], :]  # start of edges
        xy_edge2 = mesh['vertices'][edge[:, 1], :]  # end of edges
        xy_edge = 0.5 * (xy_edge1 + xy_edge2)  # middle point

        dof = np.vstack((mesh['vertices'], xy_edge))

        num_dof = np.zeros((N_tri, 6), dtype=mesh['triangles'].dtype)
        num_dof[:, 0:3] = mesh['triangles']
        num_dof[:, 3:6] = ElementEdges + N_vert

    return dof, num_dof


def fe_space(
        mesh,
        order=2,
        return_integ=True,
        return_h=False,
        order_int=None):
    """
    Compute the finite element space for a given mesh.

    Parameters
    ----------
    mesh : triangle mesh
        Generated by calling finis.triangulate or triangle.triangulate (more general).
    order : int, optional
        Order of the shape functions. Currently {0, 1, 2} are implemented.
    return_integ : bool, optional
        If set, the coordinates of the integration points will be returned in fe['integ'].
    return_h : bool, optional
        If set, the lengths of all edges will be returned in fe['h'].
    order_int : int, optional
        The order of the integration formula used. Default order_int = order.

    Returns
    -------
    fe : dict of str
        'dof' : (N_dof, 2) ndarray
            Coordinates of the degrees of freedom, e.g. the coordinates of the vertices for order=1.
            N_dof is the number of degrees of freedom.
        'num_dof' : (N_tri, N_b) ndarray
            N_tri is the number of triangles and N_b is the number of shape functions per triangle,
            e.g. 3 for order=1. num_dof[i,:] are the degrees of freedom for triangle i (by their index).
        'U' : (N_int*N_tri, N_dof) scipy.sparse.csr_matrix
            N_int is the number of integration points per triangle.
            U maps the values of a function given at the degrees of freedom to the integration points.
            The degree of freedom values are interpolated using the shape functions.
        'DUX' : (N_int*N_tri, N_dof) scipy.sparse.csr_matrix
            DUX maps the values function given at the degrees of freedom
            to the d/dx derivative given at the points of integration.
            The degree of freedom values are interpolated using the shape functions.
        'DUY' : (N_int*N_tri, N_dof) scipy.sparse.csr_matrix
            DUY maps the values function given at the degrees of freedom
            to the d/dy derivative given at the points of integration.
            The degree of freedom values are interpolated using the shape functions.
        'w' : (N_int*N_tri, ) ndarray
            The integration weights. For polygonal domains np.sum(fe['w']) should give the area of the polygon.
        'integ' : (N_int*N_tri, 2) ndarray, optional
            The coordinates of the integration points, i.e. integ[i,:] = (x,y) of integration point i.
            Only returned if return_inte=True
        'h' : (N_edges, ) ndarray, optional
            The lengths of all edges. Only returned if return_h=True.
            The enumeration follows finis._edges.meshEdges

    See Also
    --------
    finis.triangulate
    """
    if order_int is None:
        order_int = order

    # tables for finite element dofs
    dof, num_dof = _fe_dof(mesh, order=order)
    N_dof = dof.shape[0]  # total number of dof
    N_b = num_dof.shape[1]  # number of shape functions per triangle

    N_tri = mesh['triangles'].shape[0]  # Number of triangles

    xh, yh, wh = form_int_2d(order=order_int)
    N_int = xh.size  # number integration points per triangle

    phi, dxphi, dyphi = lagrange_2d(xh, yh, order=order)
    assert phi.shape[0] == N_int, "Number of integration points"
    assert phi.shape[1] == N_b, "Number of shape functions per triangle"

    # Attention: The following code is fully vectorized and horrible to
    # understand. Sorry.

    ### U ###
    # 0,0,...0, 1, 1, ...., 1, ....
    rows = np.repeat(np.arange(N_tri * N_int), N_b)
    # dofs of triangle 0, dofs of traingle 0 , ...., dofs of triangle 1, ...
    cols = np.tile(num_dof, reps=(1, N_int)).flatten(order='C')
    data = np.tile(phi.flatten(order='C'), N_tri)

    U = csr_matrix((data, (rows, cols)), shape=(N_tri * N_int, N_dof))

    ### Derivative Transforms ###
    xT = triangle_x(mesh)
    yT = triangle_y(mesh)

    dx_dxh = xT[:, 1] - xT[:, 0]
    dx_dyh = xT[:, 2] - xT[:, 0]
    dy_dxh = yT[:, 1] - yT[:, 0]
    dy_dyh = yT[:, 2] - yT[:, 0]

    det = dx_dxh * dy_dyh - dx_dyh * dy_dxh
    det_inv = 1.0 / det
    assert np.amax(np.abs(det_inv)) < 1e5, "Badly scaled triangles"

    dxh_dx = det_inv * dy_dyh
    dyh_dy = det_inv * dx_dxh
    dxh_dy = - det_inv * dx_dyh
    dyh_dx = - det_inv * dy_dxh

    ### Transform Differentials ###
    dphi_dxh = np.tile(dxphi.flatten(order='C'), N_tri)
    dphi_dyh = np.tile(dyphi.flatten(order='C'), N_tri)

    dphi_dx = dphi_dxh * np.repeat(dxh_dx,
                                   N_b * N_int) + dphi_dyh * np.repeat(dyh_dx,
                                                                       N_b * N_int)
    dphi_dy = dphi_dxh * np.repeat(dxh_dy,
                                   N_b * N_int) + dphi_dyh * np.repeat(dyh_dy,
                                                                       N_b * N_int)

    ### DUX, DUY ###
    DUX = csr_matrix((dphi_dx, (rows, cols)), shape=(N_tri * N_int, N_dof))
    DUY = csr_matrix((dphi_dy, (rows, cols)), shape=(N_tri * N_int, N_dof))

    fe = {
        'dof': dof,
        'num_dof': num_dof,
        'U': U,
        'DUX': DUX,
        'DUY': DUY,
        'w': np.repeat(np.abs(det), N_int) * np.tile(wh, N_tri),
    }

    if return_integ:
        x_int = np.zeros((N_int * N_tri, ))
        y_int = np.zeros((N_int * N_tri, ))

        for i in range(N_tri):
            x_int[N_int * i:N_int * (i + 1)] = xT[i, 0] + \
                dx_dxh[i] * xh + dx_dyh[i] * yh
            y_int[N_int * i:N_int * (i + 1)] = yT[i, 0] + \
                dy_dxh[i] * xh + dy_dyh[i] * yh

        fe['integ'] = np.hstack((x_int[:, None], y_int[:, None]))

    if return_h:
        edge, edge_markers, ElementEdges = meshEdges(mesh)

        xy_edge1 = mesh['vertices'][edge[:, 0], :]  # start of edges
        xy_edge2 = mesh['vertices'][edge[:, 1], :]  # end of edges

        fe['h'] = np.sqrt(np.sum((xy_edge1 - xy_edge2)**2, axis=1))

    return fe


class FinisNodeVisitor(ast.NodeVisitor):
    """
    Node visitor that collects functions and derivatives.
    Only used inside integrate
    """

    def __init__(self):
        self.fun_names = list()
        self.fun_names_dx = list()
        self.fun_names_dy = list()
        super().__init__()

    def visit_Name(self, node):
        if not node.id.startswith("np"):
            if node.id.startswith("dx_"):
                self.fun_names_dx.append(node.id[3:])
            elif node.id.startswith("dy_"):
                self.fun_names_dy.append(node.id[3:])
            else:
                self.fun_names.append(node.id)
        ast.NodeVisitor.generic_visit(self, node)


def integrate(fe, integrand, funs=None):
    """
    Integrate a function using the finite element space fe.

    This method has two different ways of being called:
    a) integrate(fe, integrand)
        where integrand is a function taking two arguments x,y.
    b) integrate(fe, integrand, funs)
        where integrand is a string and funs is a dict of functions.

    For a) the function integrand is integrated on fe. For b) the string
    integrand is evaluated using the functions in funs and the result is
    integrated on fe.

    Parameters
    ----------
    fe : finite element space
        Generated by calling finis.fe_space.
        Must have been called with return_integ=True.
    integrand : callable or string
        Either a) a callable function taking the two arguments x,y,
        or b) a string that represents an evaluatable python expression.
    funs : (dict of str : callables), optional
        Dict of callables taking two arguments x, y which will be inserted into
        integrand. Only needed for variant b.

    Returns
    -------
    I : float
        Numeric value of the integral

    Notes b
    -------
    Integrand has the following syntax rules:
        - Functions can have any name, e.g. f, g, h but must be present in the funs dict
        - Each function can be derived exactly once by writing either dx_f or dy_f
        - Each function f or derivative dx_f will be replaced by a numpy ndarray of shape
            (N, ) holding the values at the integration points. Make sure that function definitions
            and the integrand expression are vectorized
        - The only functions that can be called are those inside numy (using np.), e.g. np.sin(f)
        - Standard unary and binary expressions like +,-,*,** are valid
    It is advisable to look at the example.

    Examples a)
    -----------
    >>> import numpy as np
    >>> import finis
    >>> mesh = finis.triangulate()
    >>> fe = finis.fe_space(mesh, order=2)
    >>> integrand = lambda x,y: np.exp(x)
    >>> I = finis.integrate(fe, integrand)
    >>> print("Numeric : {}".format(I))
    >>> print("Analytic: {}".format(np.expm1(1)))
    Numeric : 1.7182772860575093
    Analytic: 1.718281828459045


    Examples b)
    -----------
    Integrating an integrand with derivatives and functions:
    >>> import numpy as np
    >>> import finis
    >>> mesh = finis.triangulate()
    >>> fe = finis.fe_space(mesh, order=2)
    >>> integrand = "np.sin(np.pi*x)**2 * dy_f"
    >>> funs = {
    >>>     'x': lambda x,y: x,
    >>>     'f': lambda x,y: y**3,
    >>> }
    >>> I = finis.integrate(fe, integrand, funs)
    >>> print("Numeric : {}".format(I))
    >>> print("Analytic: {}".format(0.5)) # separable integral: (int ... dx) * (int ... dy)
    Numeric : 0.5000000000000001
    Analytic: 0.5


    Showing the integration by parts rule for functions f, g with f*g = 0 on vertical borders
    >>> import numpy as np
    >>> import finis
    >>> mesh = finis.triangulate()
    >>> fe = finis.fe_space(mesh, order=2)
    >>> integrand = "dx_f*g + f*dx_g"
    >>> funs = {
        >>> 'f': lambda x,y: np.sin(x * (1-x) * np.exp(y)),
        >>> 'g': lambda x,y: np.cos(x**2 + y**3),
    >>> }
    >>> I = finis.integrate(fe, integrand, funs)
    >>> print("Numeric : {}".format(I))
    >>> print("Analytic: {}".format(0.0))
    Numeric : 9.972496077168339e-05
    Analytic: 0.0

    See Also
    --------
    finis.fe_space

    """

    assert 'integ' in fe, "Please use fe = finis.fe_space(...., return_integ=True)"

    if funs is None:
        # Direct Integrate
        I = integrand(fe['integ'][:, 0], fe['integ'][:, 1])
        return np.sum(fe['w'] * I)
    else:
        # Parsing
        node = ast.parse(integrand, mode="eval")

        # Collect functions and derivatives used
        visitor = FinisNodeVisitor()
        visitor.visit(node)
        fun_names = set().union(
            visitor.fun_names,
            visitor.fun_names_dy,
            visitor.fun_names_dx)
        for name in fun_names:
            if name not in funs:
                raise ValueError(
                    "The name '{}' is in integrand but no function is provided in funs.".format(name))

        # Compute the functions and their derivatives
        _locals = {
            'funs': funs,
            'fe': fe,
        }
        for name in visitor.fun_names:
            pattern = "{} = funs['{}'](fe['integ'][:,0], fe['integ'][:,1])"
            s = pattern.format(name, name)
            exec(s, {}, _locals)
        for name in visitor.fun_names_dx:
            pattern = "dx_{} = fe['DUX'].dot(funs['{}'](fe['dof'][:,0], fe['dof'][:,1]))"
            s = pattern.format(name, name)
            exec(s, {}, _locals)
        for name in visitor.fun_names_dy:
            pattern = "dy_{} = fe['DUY'].dot(funs['{}'](fe['dof'][:,0], fe['dof'][:,1]))"
            s = pattern.format(name, name)
            exec(s, {}, _locals)

        # Evaluate the expression
        I = eval(compile(node, filename='', mode='eval'), {'np': np}, _locals)
        return np.sum(fe['w'] * I)
