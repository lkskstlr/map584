import numpy as np
import matplotlib.pyplot as plt


def triangle_x(mesh):
    return mesh['vertices'][mesh['triangles'], 0]


def triangle_y(mesh):
    return mesh['vertices'][mesh['triangles'], 1]


def triangle_cog_x(mesh):
    return np.mean(triangle_x(mesh), axis=1)


def triangle_cog_y(mesh):
    return np.mean(triangle_y(mesh), axis=1)


def triangle_cog(mesh):
    return np.hstack(
        (triangle_cog_x(mesh)[:, None], triangle_cog_y(mesh)[:, None]))


def plot_mesh(mesh, vertex_numbers=False, triangle_numbers=False,
              edge_numbers=False, edge_labels=False, fig=None):
    have_to_show = False
    if fig is None:
        fig = plt.figure()
        have_to_show = True

    plt.triplot(mesh['vertices'][:, 0], mesh['vertices']
                [:, 1], mesh['triangles'])

    if vertex_numbers:
        for i in range(mesh['vertices'].shape[0]):
            plt.text(mesh['vertices'][i, 0], mesh['vertices'][i, 1], str(i),
                     color='r',
                     horizontalalignment='center',
                     verticalalignment='center')

    if triangle_numbers:
        cogs = triangle_cog(mesh)
        for i in range(cogs.shape[0]):
            plt.text(cogs[i, 0], cogs[i, 1], str(i))

    if edge_labels or edge_numbers:
        from ._edges import meshEdges
        edge, edge_markers, ElementEdges = meshEdges(mesh)

    if edge_numbers:
        for i in range(edge.shape[0]):
            _x = np.mean(mesh['vertices'][edge[i, :], 0])
            _y = np.mean(mesh['vertices'][edge[i, :], 1])
            plt.text(_x, _y, str(i), color='g')

    if edge_labels:
        for i in range(edge.shape[0]):
            _x = np.mean(mesh['vertices'][edge[i, :], 0])
            _y = np.mean(mesh['vertices'][edge[i, :], 1])
            plt.text(_x, _y, edge_markers[i, 0], color='g')

    if have_to_show:
        plt.show()


def triangulate(vertices=None, max_area=0.1, geom=None, **kwargs):
    """
    Small wrapper around triangle.triangulate.

    Parameters
    ----------
    vertices : (N, 2) ndarray, optional
        Vertices of the polygonal, connected area. It is assumed that they are connected in order and the last to the first.
        The standard rectangle [0,1] x [0,1] is the default.
    max_area : float, optional
        Maximal area of triangles in the triangulation.
    geom : str, optional
        String identifying the geometry. Possibilities:
            square: [0,1]^2
            square-disk: [0,1]^2 - disk of radius 0.25
            project: [0,2] x [0,10] with hole at mx, my

    Returns
    -------
    mesh : triangle mesh
        A mesh generated by calling triangle.
    """

    import triangle
    
    if (vertices is None) and (geom is None):
        geom = 'square'
    
    assert (vertices is None) or (geom is None), "Specify only one"
        
    if not (geom is None):
        if geom.lower() == 'square':
            vertices = np.array([[0., 0], [1, 0], [1, 1], [0, 1]])
            N = vertices.shape[0]
            ind = np.arange(N, dtype=np.int32)
            g = {
                'vertices': vertices,
                'segments': np.hstack((ind[:, None], np.roll(ind, -1)[:, None]))
            }
        elif geom.lower() == "square-disk":
            if 'n' not in kwargs:
                n = 20
            else:
                n = kwargs['n']
            
            vert_outer = np.array([[0., 0], [1, 0], [1, 1], [0, 1]])
            seg_outer = np.copy(np.array([[0, 1, 2, 3], [1, 2, 3, 0]]).T)

            r_circle = 0.25
            t_circle = np.linspace(0, 2*np.pi, n, endpoint=False)
            x_circle = r_circle*np.cos(t_circle) + 0.5
            y_circle = r_circle*np.sin(t_circle) + 0.5

            vert_inner = np.hstack((x_circle[:, None], y_circle[:, None]))
            ind_inner = np.arange(n)+4
            seg_inner = np.hstack((ind_inner[:, None], np.roll(ind_inner, -1)[:, None]))

            g = {
                'vertices': np.vstack((vert_outer, vert_inner)),
                'segments': np.vstack((seg_outer, seg_inner)),
                'holes': np.array([[0.5, 0.5]]),
            }
            
        elif geom.lower() == 'project':
            if ('mx' not in kwargs) or ('my' not in kwargs):
                raise ValueError("For geom 'project' mx and my have to be specified")
            if kwargs['mx'] <= 0.25 or kwargs['mx'] >= 1.75:
                raise ValueError("mx out of bounds")
            if kwargs['my'] <= 0.25 or kwargs['my'] >= 9.75:
                raise ValueError("my out of bounds")
                
            if 'n' not in kwargs:
                n = 20
            else:
                n = kwargs['n']
            
            vert_outer = np.array([[0., 0], [2, 0], [2, 10], [0, 10]])
            seg_outer = np.copy(np.array([[0, 1, 2, 3], [1, 2, 3, 0]]).T)

            r_circle = 0.25
            t_circle = np.linspace(0, 2*np.pi, n, endpoint=False)
            x_circle = r_circle*np.cos(t_circle) + kwargs['mx']
            y_circle = r_circle*np.sin(t_circle) + kwargs['my']

            vert_inner = np.hstack((x_circle[:, None], y_circle[:, None]))
            ind_inner = np.arange(n)+4
            seg_inner = np.hstack((ind_inner[:, None], np.roll(ind_inner, -1)[:, None]))

            g = {
                'vertices': np.vstack((vert_outer, vert_inner)),
                'segments': np.vstack((seg_outer, seg_inner)),
                'holes': np.array([[kwargs['mx'], kwargs['my']]]),
            }
            
    else:
        N = vertices.shape[0]
        ind = np.arange(N, dtype=np.int32)
        g = {
            'vertices': vertices,
            'segments': np.hstack((ind[:, None], np.roll(ind, -1)[:, None]))
        }

    mesh = triangle.triangulate(g, "pqDa" + str(max_area))
    return mesh
